import PropTypes from 'prop-types';
import React, { Component } from 'react';

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();









var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

/**
 * @class TimerMachine
 */

var TimerMachine = function (_Component) {
  inherits(TimerMachine, _Component);
  createClass(TimerMachine, null, [{
    key: "msToTime",
    value: function msToTime(ms) {
      var milliseconds = ms % 1000;
      ms = (ms - milliseconds) / 1000;
      var seconds = ms % 60;
      ms = (ms - seconds) / 60;
      var minutes = ms % 60;
      var hours = (ms - minutes) / 60;

      return {
        h: hours,
        m: minutes,
        s: seconds,
        ms: milliseconds
      };
    }
  }, {
    key: "formatTime",
    value: function formatTime(time) {
      var pad = function pad(n) {
        var z = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
        return ("00" + n).slice(-z);
      };
      return pad(time.h) + ":" + pad(time.m) + ":" + pad(time.s) + "." + pad(time.ms, 3);
    }
  }]);

  function TimerMachine(props) {
    classCallCheck(this, TimerMachine);

    var _this = possibleConstructorReturn(this, (TimerMachine.__proto__ || Object.getPrototypeOf(TimerMachine)).call(this, props));

    _this.state = {
      time: TimerMachine.msToTime(props.timeStart),
      milliseconds: props.timeStart
    };
    _this.timer = 0;
    _this.every = props.interval;
    _this.internalState = 0; //  0 = idle, 1 = running, 2 = paused, 3 = resumed
    _this.remaining = 0;
    _this.startTime = 0;

    _this.startTimer = _this.startTimer.bind(_this);
    _this.pauseTimer = _this.pauseTimer.bind(_this);
    _this.resumeTimer = _this.resumeTimer.bind(_this);
    _this.stopTimer = _this.stopTimer.bind(_this);
    _this.resetTimer = _this.resetTimer.bind(_this);
    _this.timeoutCallback = _this.timeoutCallback.bind(_this);
    _this.tick = _this.tick.bind(_this);
    return _this;
  }

  createClass(TimerMachine, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      var _props = this.props,
          timeStart = _props.timeStart,
          countdown = _props.countdown,
          started = _props.started,
          paused = _props.paused,
          interval = _props.interval;
      var milliseconds = this.state.milliseconds;


      this.every = countdown ? -interval : interval;

      if (started) {
        // start timer if not started already
        if (this.internalState === 0) {
          this.resetTimer();
          this.startTimer();
        }
        if (paused) {
          this.pauseTimer();
        } else {
          this.resumeTimer();
        }
      } else {
        if (timeStart !== milliseconds) {
          this.stopTimer();
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.stopTimer();
    }
  }, {
    key: "startTimer",
    value: function startTimer() {
      var onStart = this.props.onStart;


      onStart(this.state.time);
      this.startTime = new Date();
      this.timer = setInterval(this.tick, this.props.interval);
      this.internalState = 1;
    }
  }, {
    key: "stopTimer",
    value: function stopTimer() {
      var onStop = this.props.onStop;


      onStop(this.state.time);
      if (this.timer) {
        clearInterval(this.timer);
      }
      this.timer = 0;
      this.internalState = 0;
    }
  }, {
    key: "pauseTimer",
    value: function pauseTimer() {
      if (this.internalState !== 1) return;

      var _props2 = this.props,
          interval = _props2.interval,
          onPause = _props2.onPause;


      onPause(this.state.time);
      this.remaining = interval - (new Date() - this.startTime);
      clearInterval(this.timer);
      this.internalState = 2;
    }
  }, {
    key: "resumeTimer",
    value: function resumeTimer() {
      if (this.internalState !== 2) return;
      var onResume = this.props.onResume;


      onResume(this.state.time);
      window.setTimeout(this.timeoutCallback, this.remaining);
      this.internalState = 3;
    }
  }, {
    key: "resetTimer",
    value: function resetTimer() {
      var timeStart = this.props.timeStart;

      this.setState({
        time: TimerMachine.msToTime(timeStart),
        milliseconds: timeStart
      });
    }
  }, {
    key: "timeoutCallback",
    value: function timeoutCallback() {
      if (this.internalState !== 3) return;

      this.tick();

      this.startTime = new Date();
      this.timer = setInterval(this.tick, this.props.interval);
      this.internalState = 1;
    }
  }, {
    key: "tick",
    value: function tick() {
      // Remove interval, set state so a re-render happens.
      var _props3 = this.props,
          onComplete = _props3.onComplete,
          onTick = _props3.onTick,
          timeEnd = _props3.timeEnd,
          countdown = _props3.countdown;
      var milliseconds = this.state.milliseconds;


      var msRemaining = milliseconds + this.every;
      var timeRemaining = TimerMachine.msToTime(msRemaining);
      this.setState({
        time: timeRemaining,
        milliseconds: msRemaining
      });
      onTick(timeRemaining);

      // Check if timer completed.
      if (countdown && msRemaining <= timeEnd || !countdown && timeEnd && msRemaining >= timeEnd) {
        this.stopTimer();
        onComplete(timeRemaining);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _state = this.state,
          time = _state.time,
          milliseconds = _state.milliseconds;

      var timer = this.props.formatTimer(time, milliseconds);

      return React.createElement(
        React.Fragment,
        null,
        timer
      );
    }
  }]);
  return TimerMachine;
}(Component);

TimerMachine.propTypes = {
  timeStart: PropTypes.number.isRequired,
  timeEnd: PropTypes.number,
  countdown: PropTypes.bool,
  interval: PropTypes.number,
  started: PropTypes.bool,
  paused: PropTypes.bool,
  formatTimer: PropTypes.func,
  onTick: PropTypes.func,
  onStart: PropTypes.func,
  onPause: PropTypes.func,
  onResume: PropTypes.func,
  onStop: PropTypes.func,
  onComplete: PropTypes.func
};

TimerMachine.defaultProps = {
  timeEnd: 0,
  countdown: false,
  interval: 1000,
  started: false,
  paused: false,
  formatTimer: function formatTimer(time, ms) {
    return TimerMachine.formatTime(time);
  },
  onTick: function onTick(time) {},
  onStart: function onStart(time) {},
  onPause: function onPause(time) {},
  onResume: function onResume(time) {},
  onStop: function onStop(time) {},
  onComplete: function onComplete(time) {}
};

export default TimerMachine;
